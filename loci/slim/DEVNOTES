  This document is intended to outline some of the thoughts behind the work done over the last couple semesters, and things I'd like to do if the work were to be continued.

  The main idea behind the current curve fitting scheme is the idea of quick estimation. Most iterative curve fitting schemes take some sort of estimate about the parameters of the curve, and then adjust them iteratively to try to reduce the chi squared error of the curve. I felt that by being able to use what we know about the particular kinds of curves we want to fit, it would be possible to create a very quick estimation of the curve. Not only does this aid in the iteration process (since most of these curve fitting algorithms perform very badly if the initial estimate is bad), but with the changes that were made to the graphics rendering, it allows us to display information to the user more quickly. 

  Since we wanted to do estimation for single and double component curves only, I created two different estimation schemes. The estimation for single component is very simple; using the slope of the curve between two points, slope estimates are determined for the curve, and these are combined to make a lifetime estimate. 

  For two component, the idea is slightly more complicated. In a two component curve, it turns out that the slope of the curve at the beginning is closer to that of the shorter lifetime, and the slope at the end is closer to the longer lifetime, for a number of reasons. To generate the estimate, we take the slopes at the end of the curve to generate an estimate for the first component, and then we subtract it out of the curve. Then, using the remaining curve, we generate an estimate for a second component.

  This approach works well for curves that have smaller amounts of noise. Unfortunately, the curves that we generally look at in this program have far more noise, and generally cannot be estimated by this method. In this case, we generate a curve estimate that fits one component, and rely on the iteration process to separate out the components. 

  Once we have an estimate for the curve, a genetic algorithm is used to iteratively adjust the curve, to reduce the error of the curve. The genetic algorithm uses the various parameters of the curves (a, b, c of ae^-bt+c) as genetic data, and generates more generations using an inverse of the chi squared error as a fitness function. In practice this seems to work reasonably well.

  Were this work to continue in future semesters, there are several glaring items that I would want to work on:

  1) Improve estimates on noisier data. While more noise means worse fits in any case, I certainly believe that it is possible to generate better quick estimates for noisy data. In particular, I would like to research ways to improve the double component estimation functions, which, while they work well in theory, do not work so well in practice. 
  2) Use further information about what we expect in curves to make the estimate function faster. Right now, the estimation is still fairly generalized. But, for example, we seem to very rarely work with lifetimes outside the 800-3000ps range. With this information, we might be able to make more specific tweaks to the estimation routines.
  3) Improve the speed of the algorithm used for iteration. I believe that reworking some of the math used, as well as using caching of various computed results, could improve the speed of iteration. Some simple profiling shows that large (90%+) amounts of time are spent, for example, in the computation of e^x kinds of functions. These could probably be cached, or removed entirely by working with logs of the data instead.
  4) Provide different kinds of Renderers and CurveFitters. While I initially experimented with multiple different kinds of curve fitting algorithms, I only spent significant time bringing one into full development. It may turn out, though, that different algorithms are better on different kinds of data, so it would be beneficial to implement more of them more fully. The framework that we developed would allow for us to reasonably quickly do this sort of work.

  I'd like to thank Curtis Rueden, Kevin Eliceiri, John White, and Steve Trier for all of their help during the development process, and wish them good luck in future development.

  -Eric Kjellman (ekjellman@gmail.com)
